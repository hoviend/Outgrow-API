// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"outgrow/ent/event"
	"outgrow/ent/masteraccount"
	"outgrow/ent/masteraccountcategory"
	"outgrow/ent/masteraccounttype"
	"outgrow/ent/mastereventtype"
	"outgrow/ent/organization"
	"outgrow/ent/organizationaccount"
	"outgrow/ent/organizationaccountcategory"
	"outgrow/ent/organizationaccounttype"
	"outgrow/ent/organizationeventtype"
	"outgrow/ent/predicate"
	"outgrow/ent/schema"
	"outgrow/ent/transaction"
	"outgrow/ent/user"
	"outgrow/enum"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEvent                       = "Event"
	TypeMasterAccount               = "MasterAccount"
	TypeMasterAccountCategory       = "MasterAccountCategory"
	TypeMasterAccountType           = "MasterAccountType"
	TypeMasterEventType             = "MasterEventType"
	TypeOrganization                = "Organization"
	TypeOrganizationAccount         = "OrganizationAccount"
	TypeOrganizationAccountCategory = "OrganizationAccountCategory"
	TypeOrganizationAccountType     = "OrganizationAccountType"
	TypeOrganizationEventType       = "OrganizationEventType"
	TypeTransaction                 = "Transaction"
	TypeUser                        = "User"
)

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	amount              *float64
	addamount           *float64
	notes               *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	transactions        map[uuid.UUID]struct{}
	removedtransactions map[uuid.UUID]struct{}
	clearedtransactions bool
	_type               *int
	cleared_type        bool
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*Event, error)
	predicates          []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uuid.UUID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *EventMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EventMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EventMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetEventTypeID sets the "event_type_id" field.
func (m *EventMutation) SetEventTypeID(i int) {
	m._type = &i
}

// EventTypeID returns the value of the "event_type_id" field in the mutation.
func (m *EventMutation) EventTypeID() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypeID returns the old "event_type_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypeID: %w", err)
	}
	return oldValue.EventTypeID, nil
}

// ResetEventTypeID resets all changes to the "event_type_id" field.
func (m *EventMutation) ResetEventTypeID() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *EventMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *EventMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *EventMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *EventMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *EventMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetNotes sets the "notes" field.
func (m *EventMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *EventMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *EventMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[event.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *EventMutation) NotesCleared() bool {
	_, ok := m.clearedFields[event.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *EventMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, event.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *EventMutation) AddTransactionIDs(ids ...uuid.UUID) {
	if m.transactions == nil {
		m.transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *EventMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *EventMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *EventMutation) RemoveTransactionIDs(ids ...uuid.UUID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *EventMutation) RemovedTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *EventMutation) TransactionsIDs() (ids []uuid.UUID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *EventMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// SetTypeID sets the "type" edge to the OrganizationEventType entity by id.
func (m *EventMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the OrganizationEventType entity.
func (m *EventMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the OrganizationEventType entity was cleared.
func (m *EventMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *EventMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *EventMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EventMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EventMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EventMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EventMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.organization != nil {
		fields = append(fields, event.FieldOrganizationID)
	}
	if m._type != nil {
		fields = append(fields, event.FieldEventTypeID)
	}
	if m.amount != nil {
		fields = append(fields, event.FieldAmount)
	}
	if m.notes != nil {
		fields = append(fields, event.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldOrganizationID:
		return m.OrganizationID()
	case event.FieldEventTypeID:
		return m.EventTypeID()
	case event.FieldAmount:
		return m.Amount()
	case event.FieldNotes:
		return m.Notes()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case event.FieldEventTypeID:
		return m.OldEventTypeID(ctx)
	case event.FieldAmount:
		return m.OldAmount(ctx)
	case event.FieldNotes:
		return m.OldNotes(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case event.FieldEventTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypeID(v)
		return nil
	case event.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case event.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, event.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldNotes) {
		fields = append(fields, event.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case event.FieldEventTypeID:
		m.ResetEventTypeID()
		return nil
	case event.FieldAmount:
		m.ResetAmount()
		return nil
	case event.FieldNotes:
		m.ResetNotes()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.transactions != nil {
		edges = append(edges, event.EdgeTransactions)
	}
	if m._type != nil {
		edges = append(edges, event.EdgeType)
	}
	if m.organization != nil {
		edges = append(edges, event.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransactions != nil {
		edges = append(edges, event.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtransactions {
		edges = append(edges, event.EdgeTransactions)
	}
	if m.cleared_type {
		edges = append(edges, event.EdgeType)
	}
	if m.clearedorganization {
		edges = append(edges, event.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeTransactions:
		return m.clearedtransactions
	case event.EdgeType:
		return m.cleared_type
	case event.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeType:
		m.ClearType()
		return nil
	case event.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case event.EdgeType:
		m.ResetType()
		return nil
	case event.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// MasterAccountMutation represents an operation that mutates the MasterAccount nodes in the graph.
type MasterAccountMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	accCategory        *int
	clearedaccCategory bool
	done               bool
	oldValue           func(context.Context) (*MasterAccount, error)
	predicates         []predicate.MasterAccount
}

var _ ent.Mutation = (*MasterAccountMutation)(nil)

// masteraccountOption allows management of the mutation configuration using functional options.
type masteraccountOption func(*MasterAccountMutation)

// newMasterAccountMutation creates new mutation for the MasterAccount entity.
func newMasterAccountMutation(c config, op Op, opts ...masteraccountOption) *MasterAccountMutation {
	m := &MasterAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeMasterAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMasterAccountID sets the ID field of the mutation.
func withMasterAccountID(id int) masteraccountOption {
	return func(m *MasterAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *MasterAccount
		)
		m.oldValue = func(ctx context.Context) (*MasterAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MasterAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMasterAccount sets the old MasterAccount of the mutation.
func withMasterAccount(node *MasterAccount) masteraccountOption {
	return func(m *MasterAccountMutation) {
		m.oldValue = func(context.Context) (*MasterAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MasterAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MasterAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MasterAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MasterAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MasterAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategoryID sets the "category_id" field.
func (m *MasterAccountMutation) SetCategoryID(i int) {
	m.accCategory = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *MasterAccountMutation) CategoryID() (r int, exists bool) {
	v := m.accCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the MasterAccount entity.
// If the MasterAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *MasterAccountMutation) ResetCategoryID() {
	m.accCategory = nil
}

// SetName sets the "name" field.
func (m *MasterAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MasterAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MasterAccount entity.
// If the MasterAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MasterAccountMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MasterAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MasterAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MasterAccount entity.
// If the MasterAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MasterAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAccCategoryID sets the "accCategory" edge to the MasterAccountCategory entity by id.
func (m *MasterAccountMutation) SetAccCategoryID(id int) {
	m.accCategory = &id
}

// ClearAccCategory clears the "accCategory" edge to the MasterAccountCategory entity.
func (m *MasterAccountMutation) ClearAccCategory() {
	m.clearedaccCategory = true
}

// AccCategoryCleared reports if the "accCategory" edge to the MasterAccountCategory entity was cleared.
func (m *MasterAccountMutation) AccCategoryCleared() bool {
	return m.clearedaccCategory
}

// AccCategoryID returns the "accCategory" edge ID in the mutation.
func (m *MasterAccountMutation) AccCategoryID() (id int, exists bool) {
	if m.accCategory != nil {
		return *m.accCategory, true
	}
	return
}

// AccCategoryIDs returns the "accCategory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccCategoryID instead. It exists only for internal usage by the builders.
func (m *MasterAccountMutation) AccCategoryIDs() (ids []int) {
	if id := m.accCategory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccCategory resets all changes to the "accCategory" edge.
func (m *MasterAccountMutation) ResetAccCategory() {
	m.accCategory = nil
	m.clearedaccCategory = false
}

// Where appends a list predicates to the MasterAccountMutation builder.
func (m *MasterAccountMutation) Where(ps ...predicate.MasterAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MasterAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MasterAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MasterAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MasterAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MasterAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MasterAccount).
func (m *MasterAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MasterAccountMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.accCategory != nil {
		fields = append(fields, masteraccount.FieldCategoryID)
	}
	if m.name != nil {
		fields = append(fields, masteraccount.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, masteraccount.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MasterAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case masteraccount.FieldCategoryID:
		return m.CategoryID()
	case masteraccount.FieldName:
		return m.Name()
	case masteraccount.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MasterAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case masteraccount.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case masteraccount.FieldName:
		return m.OldName(ctx)
	case masteraccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MasterAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case masteraccount.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case masteraccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case masteraccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MasterAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MasterAccountMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MasterAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MasterAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MasterAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MasterAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MasterAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MasterAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MasterAccountMutation) ResetField(name string) error {
	switch name {
	case masteraccount.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case masteraccount.FieldName:
		m.ResetName()
		return nil
	case masteraccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MasterAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MasterAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accCategory != nil {
		edges = append(edges, masteraccount.EdgeAccCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MasterAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case masteraccount.EdgeAccCategory:
		if id := m.accCategory; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MasterAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MasterAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MasterAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccCategory {
		edges = append(edges, masteraccount.EdgeAccCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MasterAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case masteraccount.EdgeAccCategory:
		return m.clearedaccCategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MasterAccountMutation) ClearEdge(name string) error {
	switch name {
	case masteraccount.EdgeAccCategory:
		m.ClearAccCategory()
		return nil
	}
	return fmt.Errorf("unknown MasterAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MasterAccountMutation) ResetEdge(name string) error {
	switch name {
	case masteraccount.EdgeAccCategory:
		m.ResetAccCategory()
		return nil
	}
	return fmt.Errorf("unknown MasterAccount edge %s", name)
}

// MasterAccountCategoryMutation represents an operation that mutates the MasterAccountCategory nodes in the graph.
type MasterAccountCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	accounts        map[int]struct{}
	removedaccounts map[int]struct{}
	clearedaccounts bool
	accType         *int
	clearedaccType  bool
	done            bool
	oldValue        func(context.Context) (*MasterAccountCategory, error)
	predicates      []predicate.MasterAccountCategory
}

var _ ent.Mutation = (*MasterAccountCategoryMutation)(nil)

// masteraccountcategoryOption allows management of the mutation configuration using functional options.
type masteraccountcategoryOption func(*MasterAccountCategoryMutation)

// newMasterAccountCategoryMutation creates new mutation for the MasterAccountCategory entity.
func newMasterAccountCategoryMutation(c config, op Op, opts ...masteraccountcategoryOption) *MasterAccountCategoryMutation {
	m := &MasterAccountCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeMasterAccountCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMasterAccountCategoryID sets the ID field of the mutation.
func withMasterAccountCategoryID(id int) masteraccountcategoryOption {
	return func(m *MasterAccountCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *MasterAccountCategory
		)
		m.oldValue = func(ctx context.Context) (*MasterAccountCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MasterAccountCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMasterAccountCategory sets the old MasterAccountCategory of the mutation.
func withMasterAccountCategory(node *MasterAccountCategory) masteraccountcategoryOption {
	return func(m *MasterAccountCategoryMutation) {
		m.oldValue = func(context.Context) (*MasterAccountCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MasterAccountCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MasterAccountCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MasterAccountCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MasterAccountCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MasterAccountCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountTypeID sets the "account_type_id" field.
func (m *MasterAccountCategoryMutation) SetAccountTypeID(i int) {
	m.accType = &i
}

// AccountTypeID returns the value of the "account_type_id" field in the mutation.
func (m *MasterAccountCategoryMutation) AccountTypeID() (r int, exists bool) {
	v := m.accType
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountTypeID returns the old "account_type_id" field's value of the MasterAccountCategory entity.
// If the MasterAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountCategoryMutation) OldAccountTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountTypeID: %w", err)
	}
	return oldValue.AccountTypeID, nil
}

// ResetAccountTypeID resets all changes to the "account_type_id" field.
func (m *MasterAccountCategoryMutation) ResetAccountTypeID() {
	m.accType = nil
}

// SetName sets the "name" field.
func (m *MasterAccountCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MasterAccountCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MasterAccountCategory entity.
// If the MasterAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MasterAccountCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MasterAccountCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MasterAccountCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MasterAccountCategory entity.
// If the MasterAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MasterAccountCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[masteraccountcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MasterAccountCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[masteraccountcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MasterAccountCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, masteraccountcategory.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *MasterAccountCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MasterAccountCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MasterAccountCategory entity.
// If the MasterAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MasterAccountCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAccountIDs adds the "accounts" edge to the MasterAccount entity by ids.
func (m *MasterAccountCategoryMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the MasterAccount entity.
func (m *MasterAccountCategoryMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the MasterAccount entity was cleared.
func (m *MasterAccountCategoryMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the MasterAccount entity by IDs.
func (m *MasterAccountCategoryMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the MasterAccount entity.
func (m *MasterAccountCategoryMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *MasterAccountCategoryMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *MasterAccountCategoryMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// SetAccTypeID sets the "accType" edge to the MasterAccountType entity by id.
func (m *MasterAccountCategoryMutation) SetAccTypeID(id int) {
	m.accType = &id
}

// ClearAccType clears the "accType" edge to the MasterAccountType entity.
func (m *MasterAccountCategoryMutation) ClearAccType() {
	m.clearedaccType = true
}

// AccTypeCleared reports if the "accType" edge to the MasterAccountType entity was cleared.
func (m *MasterAccountCategoryMutation) AccTypeCleared() bool {
	return m.clearedaccType
}

// AccTypeID returns the "accType" edge ID in the mutation.
func (m *MasterAccountCategoryMutation) AccTypeID() (id int, exists bool) {
	if m.accType != nil {
		return *m.accType, true
	}
	return
}

// AccTypeIDs returns the "accType" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccTypeID instead. It exists only for internal usage by the builders.
func (m *MasterAccountCategoryMutation) AccTypeIDs() (ids []int) {
	if id := m.accType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccType resets all changes to the "accType" edge.
func (m *MasterAccountCategoryMutation) ResetAccType() {
	m.accType = nil
	m.clearedaccType = false
}

// Where appends a list predicates to the MasterAccountCategoryMutation builder.
func (m *MasterAccountCategoryMutation) Where(ps ...predicate.MasterAccountCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MasterAccountCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MasterAccountCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MasterAccountCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MasterAccountCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MasterAccountCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MasterAccountCategory).
func (m *MasterAccountCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MasterAccountCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.accType != nil {
		fields = append(fields, masteraccountcategory.FieldAccountTypeID)
	}
	if m.name != nil {
		fields = append(fields, masteraccountcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, masteraccountcategory.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, masteraccountcategory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MasterAccountCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case masteraccountcategory.FieldAccountTypeID:
		return m.AccountTypeID()
	case masteraccountcategory.FieldName:
		return m.Name()
	case masteraccountcategory.FieldDescription:
		return m.Description()
	case masteraccountcategory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MasterAccountCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case masteraccountcategory.FieldAccountTypeID:
		return m.OldAccountTypeID(ctx)
	case masteraccountcategory.FieldName:
		return m.OldName(ctx)
	case masteraccountcategory.FieldDescription:
		return m.OldDescription(ctx)
	case masteraccountcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MasterAccountCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterAccountCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case masteraccountcategory.FieldAccountTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountTypeID(v)
		return nil
	case masteraccountcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case masteraccountcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case masteraccountcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MasterAccountCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MasterAccountCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MasterAccountCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterAccountCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MasterAccountCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MasterAccountCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(masteraccountcategory.FieldDescription) {
		fields = append(fields, masteraccountcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MasterAccountCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MasterAccountCategoryMutation) ClearField(name string) error {
	switch name {
	case masteraccountcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown MasterAccountCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MasterAccountCategoryMutation) ResetField(name string) error {
	switch name {
	case masteraccountcategory.FieldAccountTypeID:
		m.ResetAccountTypeID()
		return nil
	case masteraccountcategory.FieldName:
		m.ResetName()
		return nil
	case masteraccountcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case masteraccountcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MasterAccountCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MasterAccountCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, masteraccountcategory.EdgeAccounts)
	}
	if m.accType != nil {
		edges = append(edges, masteraccountcategory.EdgeAccType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MasterAccountCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case masteraccountcategory.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case masteraccountcategory.EdgeAccType:
		if id := m.accType; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MasterAccountCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, masteraccountcategory.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MasterAccountCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case masteraccountcategory.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MasterAccountCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, masteraccountcategory.EdgeAccounts)
	}
	if m.clearedaccType {
		edges = append(edges, masteraccountcategory.EdgeAccType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MasterAccountCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case masteraccountcategory.EdgeAccounts:
		return m.clearedaccounts
	case masteraccountcategory.EdgeAccType:
		return m.clearedaccType
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MasterAccountCategoryMutation) ClearEdge(name string) error {
	switch name {
	case masteraccountcategory.EdgeAccType:
		m.ClearAccType()
		return nil
	}
	return fmt.Errorf("unknown MasterAccountCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MasterAccountCategoryMutation) ResetEdge(name string) error {
	switch name {
	case masteraccountcategory.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case masteraccountcategory.EdgeAccType:
		m.ResetAccType()
		return nil
	}
	return fmt.Errorf("unknown MasterAccountCategory edge %s", name)
}

// MasterAccountTypeMutation represents an operation that mutates the MasterAccountType nodes in the graph.
type MasterAccountTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	created_at        *time.Time
	clearedFields     map[string]struct{}
	categories        map[int]struct{}
	removedcategories map[int]struct{}
	clearedcategories bool
	done              bool
	oldValue          func(context.Context) (*MasterAccountType, error)
	predicates        []predicate.MasterAccountType
}

var _ ent.Mutation = (*MasterAccountTypeMutation)(nil)

// masteraccounttypeOption allows management of the mutation configuration using functional options.
type masteraccounttypeOption func(*MasterAccountTypeMutation)

// newMasterAccountTypeMutation creates new mutation for the MasterAccountType entity.
func newMasterAccountTypeMutation(c config, op Op, opts ...masteraccounttypeOption) *MasterAccountTypeMutation {
	m := &MasterAccountTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMasterAccountType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMasterAccountTypeID sets the ID field of the mutation.
func withMasterAccountTypeID(id int) masteraccounttypeOption {
	return func(m *MasterAccountTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MasterAccountType
		)
		m.oldValue = func(ctx context.Context) (*MasterAccountType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MasterAccountType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMasterAccountType sets the old MasterAccountType of the mutation.
func withMasterAccountType(node *MasterAccountType) masteraccounttypeOption {
	return func(m *MasterAccountTypeMutation) {
		m.oldValue = func(context.Context) (*MasterAccountType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MasterAccountTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MasterAccountTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MasterAccountTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MasterAccountTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MasterAccountType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MasterAccountTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MasterAccountTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MasterAccountType entity.
// If the MasterAccountType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MasterAccountTypeMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MasterAccountTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MasterAccountTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MasterAccountType entity.
// If the MasterAccountType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterAccountTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MasterAccountTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddCategoryIDs adds the "categories" edge to the MasterAccountCategory entity by ids.
func (m *MasterAccountTypeMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the MasterAccountCategory entity.
func (m *MasterAccountTypeMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the MasterAccountCategory entity was cleared.
func (m *MasterAccountTypeMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the MasterAccountCategory entity by IDs.
func (m *MasterAccountTypeMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the MasterAccountCategory entity.
func (m *MasterAccountTypeMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *MasterAccountTypeMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *MasterAccountTypeMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the MasterAccountTypeMutation builder.
func (m *MasterAccountTypeMutation) Where(ps ...predicate.MasterAccountType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MasterAccountTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MasterAccountTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MasterAccountType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MasterAccountTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MasterAccountTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MasterAccountType).
func (m *MasterAccountTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MasterAccountTypeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, masteraccounttype.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, masteraccounttype.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MasterAccountTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case masteraccounttype.FieldName:
		return m.Name()
	case masteraccounttype.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MasterAccountTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case masteraccounttype.FieldName:
		return m.OldName(ctx)
	case masteraccounttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MasterAccountType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterAccountTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case masteraccounttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case masteraccounttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MasterAccountType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MasterAccountTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MasterAccountTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterAccountTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MasterAccountType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MasterAccountTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MasterAccountTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MasterAccountTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MasterAccountType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MasterAccountTypeMutation) ResetField(name string) error {
	switch name {
	case masteraccounttype.FieldName:
		m.ResetName()
		return nil
	case masteraccounttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MasterAccountType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MasterAccountTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.categories != nil {
		edges = append(edges, masteraccounttype.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MasterAccountTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case masteraccounttype.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MasterAccountTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcategories != nil {
		edges = append(edges, masteraccounttype.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MasterAccountTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case masteraccounttype.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MasterAccountTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategories {
		edges = append(edges, masteraccounttype.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MasterAccountTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case masteraccounttype.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MasterAccountTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MasterAccountType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MasterAccountTypeMutation) ResetEdge(name string) error {
	switch name {
	case masteraccounttype.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown MasterAccountType edge %s", name)
}

// MasterEventTypeMutation represents an operation that mutates the MasterEventType nodes in the graph.
type MasterEventTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	rules         *[]schema.EventRules
	appendrules   []schema.EventRules
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MasterEventType, error)
	predicates    []predicate.MasterEventType
}

var _ ent.Mutation = (*MasterEventTypeMutation)(nil)

// mastereventtypeOption allows management of the mutation configuration using functional options.
type mastereventtypeOption func(*MasterEventTypeMutation)

// newMasterEventTypeMutation creates new mutation for the MasterEventType entity.
func newMasterEventTypeMutation(c config, op Op, opts ...mastereventtypeOption) *MasterEventTypeMutation {
	m := &MasterEventTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMasterEventType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMasterEventTypeID sets the ID field of the mutation.
func withMasterEventTypeID(id int) mastereventtypeOption {
	return func(m *MasterEventTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MasterEventType
		)
		m.oldValue = func(ctx context.Context) (*MasterEventType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MasterEventType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMasterEventType sets the old MasterEventType of the mutation.
func withMasterEventType(node *MasterEventType) mastereventtypeOption {
	return func(m *MasterEventTypeMutation) {
		m.oldValue = func(context.Context) (*MasterEventType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MasterEventTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MasterEventTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MasterEventTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MasterEventTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MasterEventType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MasterEventTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MasterEventTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MasterEventType entity.
// If the MasterEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterEventTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MasterEventTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MasterEventTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MasterEventTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MasterEventType entity.
// If the MasterEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterEventTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MasterEventTypeMutation) ResetDescription() {
	m.description = nil
}

// SetRules sets the "rules" field.
func (m *MasterEventTypeMutation) SetRules(sr []schema.EventRules) {
	m.rules = &sr
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *MasterEventTypeMutation) Rules() (r []schema.EventRules, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the MasterEventType entity.
// If the MasterEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterEventTypeMutation) OldRules(ctx context.Context) (v []schema.EventRules, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds sr to the "rules" field.
func (m *MasterEventTypeMutation) AppendRules(sr []schema.EventRules) {
	m.appendrules = append(m.appendrules, sr...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *MasterEventTypeMutation) AppendedRules() ([]schema.EventRules, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *MasterEventTypeMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MasterEventTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MasterEventTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MasterEventType entity.
// If the MasterEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MasterEventTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MasterEventTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the MasterEventTypeMutation builder.
func (m *MasterEventTypeMutation) Where(ps ...predicate.MasterEventType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MasterEventTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MasterEventTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MasterEventType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MasterEventTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MasterEventTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MasterEventType).
func (m *MasterEventTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MasterEventTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, mastereventtype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, mastereventtype.FieldDescription)
	}
	if m.rules != nil {
		fields = append(fields, mastereventtype.FieldRules)
	}
	if m.created_at != nil {
		fields = append(fields, mastereventtype.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MasterEventTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mastereventtype.FieldName:
		return m.Name()
	case mastereventtype.FieldDescription:
		return m.Description()
	case mastereventtype.FieldRules:
		return m.Rules()
	case mastereventtype.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MasterEventTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mastereventtype.FieldName:
		return m.OldName(ctx)
	case mastereventtype.FieldDescription:
		return m.OldDescription(ctx)
	case mastereventtype.FieldRules:
		return m.OldRules(ctx)
	case mastereventtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MasterEventType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterEventTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mastereventtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mastereventtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case mastereventtype.FieldRules:
		v, ok := value.([]schema.EventRules)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case mastereventtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MasterEventType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MasterEventTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MasterEventTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MasterEventTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MasterEventType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MasterEventTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MasterEventTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MasterEventTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MasterEventType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MasterEventTypeMutation) ResetField(name string) error {
	switch name {
	case mastereventtype.FieldName:
		m.ResetName()
		return nil
	case mastereventtype.FieldDescription:
		m.ResetDescription()
		return nil
	case mastereventtype.FieldRules:
		m.ResetRules()
		return nil
	case mastereventtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown MasterEventType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MasterEventTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MasterEventTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MasterEventTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MasterEventTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MasterEventTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MasterEventTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MasterEventTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MasterEventType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MasterEventTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MasterEventType edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	created_at          *time.Time
	public_id           *string
	clearedFields       map[string]struct{}
	users               map[uuid.UUID]struct{}
	removedusers        map[uuid.UUID]struct{}
	clearedusers        bool
	accountTypes        map[int]struct{}
	removedaccountTypes map[int]struct{}
	clearedaccountTypes bool
	eventTypes          map[int]struct{}
	removedeventTypes   map[int]struct{}
	clearedeventTypes   bool
	events              map[uuid.UUID]struct{}
	removedevents       map[uuid.UUID]struct{}
	clearedevents       bool
	done                bool
	oldValue            func(context.Context) (*Organization, error)
	predicates          []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPublicID sets the "public_id" field.
func (m *OrganizationMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *OrganizationMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *OrganizationMutation) ResetPublicID() {
	m.public_id = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddAccountTypeIDs adds the "accountTypes" edge to the OrganizationAccountType entity by ids.
func (m *OrganizationMutation) AddAccountTypeIDs(ids ...int) {
	if m.accountTypes == nil {
		m.accountTypes = make(map[int]struct{})
	}
	for i := range ids {
		m.accountTypes[ids[i]] = struct{}{}
	}
}

// ClearAccountTypes clears the "accountTypes" edge to the OrganizationAccountType entity.
func (m *OrganizationMutation) ClearAccountTypes() {
	m.clearedaccountTypes = true
}

// AccountTypesCleared reports if the "accountTypes" edge to the OrganizationAccountType entity was cleared.
func (m *OrganizationMutation) AccountTypesCleared() bool {
	return m.clearedaccountTypes
}

// RemoveAccountTypeIDs removes the "accountTypes" edge to the OrganizationAccountType entity by IDs.
func (m *OrganizationMutation) RemoveAccountTypeIDs(ids ...int) {
	if m.removedaccountTypes == nil {
		m.removedaccountTypes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accountTypes, ids[i])
		m.removedaccountTypes[ids[i]] = struct{}{}
	}
}

// RemovedAccountTypes returns the removed IDs of the "accountTypes" edge to the OrganizationAccountType entity.
func (m *OrganizationMutation) RemovedAccountTypesIDs() (ids []int) {
	for id := range m.removedaccountTypes {
		ids = append(ids, id)
	}
	return
}

// AccountTypesIDs returns the "accountTypes" edge IDs in the mutation.
func (m *OrganizationMutation) AccountTypesIDs() (ids []int) {
	for id := range m.accountTypes {
		ids = append(ids, id)
	}
	return
}

// ResetAccountTypes resets all changes to the "accountTypes" edge.
func (m *OrganizationMutation) ResetAccountTypes() {
	m.accountTypes = nil
	m.clearedaccountTypes = false
	m.removedaccountTypes = nil
}

// AddEventTypeIDs adds the "eventTypes" edge to the OrganizationEventType entity by ids.
func (m *OrganizationMutation) AddEventTypeIDs(ids ...int) {
	if m.eventTypes == nil {
		m.eventTypes = make(map[int]struct{})
	}
	for i := range ids {
		m.eventTypes[ids[i]] = struct{}{}
	}
}

// ClearEventTypes clears the "eventTypes" edge to the OrganizationEventType entity.
func (m *OrganizationMutation) ClearEventTypes() {
	m.clearedeventTypes = true
}

// EventTypesCleared reports if the "eventTypes" edge to the OrganizationEventType entity was cleared.
func (m *OrganizationMutation) EventTypesCleared() bool {
	return m.clearedeventTypes
}

// RemoveEventTypeIDs removes the "eventTypes" edge to the OrganizationEventType entity by IDs.
func (m *OrganizationMutation) RemoveEventTypeIDs(ids ...int) {
	if m.removedeventTypes == nil {
		m.removedeventTypes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.eventTypes, ids[i])
		m.removedeventTypes[ids[i]] = struct{}{}
	}
}

// RemovedEventTypes returns the removed IDs of the "eventTypes" edge to the OrganizationEventType entity.
func (m *OrganizationMutation) RemovedEventTypesIDs() (ids []int) {
	for id := range m.removedeventTypes {
		ids = append(ids, id)
	}
	return
}

// EventTypesIDs returns the "eventTypes" edge IDs in the mutation.
func (m *OrganizationMutation) EventTypesIDs() (ids []int) {
	for id := range m.eventTypes {
		ids = append(ids, id)
	}
	return
}

// ResetEventTypes resets all changes to the "eventTypes" edge.
func (m *OrganizationMutation) ResetEventTypes() {
	m.eventTypes = nil
	m.clearedeventTypes = false
	m.removedeventTypes = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *OrganizationMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *OrganizationMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *OrganizationMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *OrganizationMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *OrganizationMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *OrganizationMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *OrganizationMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.public_id != nil {
		fields = append(fields, organization.FieldPublicID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldPublicID:
		return m.PublicID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldPublicID:
		return m.OldPublicID(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldPublicID:
		m.ResetPublicID()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.accountTypes != nil {
		edges = append(edges, organization.EdgeAccountTypes)
	}
	if m.eventTypes != nil {
		edges = append(edges, organization.EdgeEventTypes)
	}
	if m.events != nil {
		edges = append(edges, organization.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAccountTypes:
		ids := make([]ent.Value, 0, len(m.accountTypes))
		for id := range m.accountTypes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEventTypes:
		ids := make([]ent.Value, 0, len(m.eventTypes))
		for id := range m.eventTypes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedaccountTypes != nil {
		edges = append(edges, organization.EdgeAccountTypes)
	}
	if m.removedeventTypes != nil {
		edges = append(edges, organization.EdgeEventTypes)
	}
	if m.removedevents != nil {
		edges = append(edges, organization.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAccountTypes:
		ids := make([]ent.Value, 0, len(m.removedaccountTypes))
		for id := range m.removedaccountTypes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEventTypes:
		ids := make([]ent.Value, 0, len(m.removedeventTypes))
		for id := range m.removedeventTypes {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedaccountTypes {
		edges = append(edges, organization.EdgeAccountTypes)
	}
	if m.clearedeventTypes {
		edges = append(edges, organization.EdgeEventTypes)
	}
	if m.clearedevents {
		edges = append(edges, organization.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeAccountTypes:
		return m.clearedaccountTypes
	case organization.EdgeEventTypes:
		return m.clearedeventTypes
	case organization.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeAccountTypes:
		m.ResetAccountTypes()
		return nil
	case organization.EdgeEventTypes:
		m.ResetEventTypes()
		return nil
	case organization.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationAccountMutation represents an operation that mutates the OrganizationAccount nodes in the graph.
type OrganizationAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	code                *string
	balance             *float64
	addbalance          *float64
	created_at          *time.Time
	clearedFields       map[string]struct{}
	transactions        map[uuid.UUID]struct{}
	removedtransactions map[uuid.UUID]struct{}
	clearedtransactions bool
	accCategory         *int
	clearedaccCategory  bool
	done                bool
	oldValue            func(context.Context) (*OrganizationAccount, error)
	predicates          []predicate.OrganizationAccount
}

var _ ent.Mutation = (*OrganizationAccountMutation)(nil)

// organizationaccountOption allows management of the mutation configuration using functional options.
type organizationaccountOption func(*OrganizationAccountMutation)

// newOrganizationAccountMutation creates new mutation for the OrganizationAccount entity.
func newOrganizationAccountMutation(c config, op Op, opts ...organizationaccountOption) *OrganizationAccountMutation {
	m := &OrganizationAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationAccountID sets the ID field of the mutation.
func withOrganizationAccountID(id int) organizationaccountOption {
	return func(m *OrganizationAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationAccount
		)
		m.oldValue = func(ctx context.Context) (*OrganizationAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationAccount sets the old OrganizationAccount of the mutation.
func withOrganizationAccount(node *OrganizationAccount) organizationaccountOption {
	return func(m *OrganizationAccountMutation) {
		m.oldValue = func(context.Context) (*OrganizationAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategoryID sets the "category_id" field.
func (m *OrganizationAccountMutation) SetCategoryID(i int) {
	m.accCategory = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *OrganizationAccountMutation) CategoryID() (r int, exists bool) {
	v := m.accCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the OrganizationAccount entity.
// If the OrganizationAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *OrganizationAccountMutation) ResetCategoryID() {
	m.accCategory = nil
}

// SetName sets the "name" field.
func (m *OrganizationAccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationAccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationAccount entity.
// If the OrganizationAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationAccountMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *OrganizationAccountMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrganizationAccountMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OrganizationAccount entity.
// If the OrganizationAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OrganizationAccountMutation) ResetCode() {
	m.code = nil
}

// SetBalance sets the "balance" field.
func (m *OrganizationAccountMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *OrganizationAccountMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the OrganizationAccount entity.
// If the OrganizationAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *OrganizationAccountMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *OrganizationAccountMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *OrganizationAccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationAccount entity.
// If the OrganizationAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *OrganizationAccountMutation) AddTransactionIDs(ids ...uuid.UUID) {
	if m.transactions == nil {
		m.transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *OrganizationAccountMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *OrganizationAccountMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *OrganizationAccountMutation) RemoveTransactionIDs(ids ...uuid.UUID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *OrganizationAccountMutation) RemovedTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *OrganizationAccountMutation) TransactionsIDs() (ids []uuid.UUID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *OrganizationAccountMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// SetAccCategoryID sets the "accCategory" edge to the OrganizationAccountCategory entity by id.
func (m *OrganizationAccountMutation) SetAccCategoryID(id int) {
	m.accCategory = &id
}

// ClearAccCategory clears the "accCategory" edge to the OrganizationAccountCategory entity.
func (m *OrganizationAccountMutation) ClearAccCategory() {
	m.clearedaccCategory = true
}

// AccCategoryCleared reports if the "accCategory" edge to the OrganizationAccountCategory entity was cleared.
func (m *OrganizationAccountMutation) AccCategoryCleared() bool {
	return m.clearedaccCategory
}

// AccCategoryID returns the "accCategory" edge ID in the mutation.
func (m *OrganizationAccountMutation) AccCategoryID() (id int, exists bool) {
	if m.accCategory != nil {
		return *m.accCategory, true
	}
	return
}

// AccCategoryIDs returns the "accCategory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccCategoryID instead. It exists only for internal usage by the builders.
func (m *OrganizationAccountMutation) AccCategoryIDs() (ids []int) {
	if id := m.accCategory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccCategory resets all changes to the "accCategory" edge.
func (m *OrganizationAccountMutation) ResetAccCategory() {
	m.accCategory = nil
	m.clearedaccCategory = false
}

// Where appends a list predicates to the OrganizationAccountMutation builder.
func (m *OrganizationAccountMutation) Where(ps ...predicate.OrganizationAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationAccount).
func (m *OrganizationAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationAccountMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.accCategory != nil {
		fields = append(fields, organizationaccount.FieldCategoryID)
	}
	if m.name != nil {
		fields = append(fields, organizationaccount.FieldName)
	}
	if m.code != nil {
		fields = append(fields, organizationaccount.FieldCode)
	}
	if m.balance != nil {
		fields = append(fields, organizationaccount.FieldBalance)
	}
	if m.created_at != nil {
		fields = append(fields, organizationaccount.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationaccount.FieldCategoryID:
		return m.CategoryID()
	case organizationaccount.FieldName:
		return m.Name()
	case organizationaccount.FieldCode:
		return m.Code()
	case organizationaccount.FieldBalance:
		return m.Balance()
	case organizationaccount.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationaccount.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case organizationaccount.FieldName:
		return m.OldName(ctx)
	case organizationaccount.FieldCode:
		return m.OldCode(ctx)
	case organizationaccount.FieldBalance:
		return m.OldBalance(ctx)
	case organizationaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationaccount.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case organizationaccount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationaccount.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case organizationaccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case organizationaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationAccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, organizationaccount.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationaccount.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationaccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrganizationAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationAccountMutation) ResetField(name string) error {
	switch name {
	case organizationaccount.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case organizationaccount.FieldName:
		m.ResetName()
		return nil
	case organizationaccount.FieldCode:
		m.ResetCode()
		return nil
	case organizationaccount.FieldBalance:
		m.ResetBalance()
		return nil
	case organizationaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transactions != nil {
		edges = append(edges, organizationaccount.EdgeTransactions)
	}
	if m.accCategory != nil {
		edges = append(edges, organizationaccount.EdgeAccCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationaccount.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case organizationaccount.EdgeAccCategory:
		if id := m.accCategory; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, organizationaccount.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationaccount.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransactions {
		edges = append(edges, organizationaccount.EdgeTransactions)
	}
	if m.clearedaccCategory {
		edges = append(edges, organizationaccount.EdgeAccCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationaccount.EdgeTransactions:
		return m.clearedtransactions
	case organizationaccount.EdgeAccCategory:
		return m.clearedaccCategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationAccountMutation) ClearEdge(name string) error {
	switch name {
	case organizationaccount.EdgeAccCategory:
		m.ClearAccCategory()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationAccountMutation) ResetEdge(name string) error {
	switch name {
	case organizationaccount.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case organizationaccount.EdgeAccCategory:
		m.ResetAccCategory()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccount edge %s", name)
}

// OrganizationAccountCategoryMutation represents an operation that mutates the OrganizationAccountCategory nodes in the graph.
type OrganizationAccountCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	accounts        map[int]struct{}
	removedaccounts map[int]struct{}
	clearedaccounts bool
	_type           *int
	cleared_type    bool
	done            bool
	oldValue        func(context.Context) (*OrganizationAccountCategory, error)
	predicates      []predicate.OrganizationAccountCategory
}

var _ ent.Mutation = (*OrganizationAccountCategoryMutation)(nil)

// organizationaccountcategoryOption allows management of the mutation configuration using functional options.
type organizationaccountcategoryOption func(*OrganizationAccountCategoryMutation)

// newOrganizationAccountCategoryMutation creates new mutation for the OrganizationAccountCategory entity.
func newOrganizationAccountCategoryMutation(c config, op Op, opts ...organizationaccountcategoryOption) *OrganizationAccountCategoryMutation {
	m := &OrganizationAccountCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationAccountCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationAccountCategoryID sets the ID field of the mutation.
func withOrganizationAccountCategoryID(id int) organizationaccountcategoryOption {
	return func(m *OrganizationAccountCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationAccountCategory
		)
		m.oldValue = func(ctx context.Context) (*OrganizationAccountCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationAccountCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationAccountCategory sets the old OrganizationAccountCategory of the mutation.
func withOrganizationAccountCategory(node *OrganizationAccountCategory) organizationaccountcategoryOption {
	return func(m *OrganizationAccountCategoryMutation) {
		m.oldValue = func(context.Context) (*OrganizationAccountCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationAccountCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationAccountCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationAccountCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationAccountCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationAccountCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountTypeID sets the "account_type_id" field.
func (m *OrganizationAccountCategoryMutation) SetAccountTypeID(i int) {
	m._type = &i
}

// AccountTypeID returns the value of the "account_type_id" field in the mutation.
func (m *OrganizationAccountCategoryMutation) AccountTypeID() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountTypeID returns the old "account_type_id" field's value of the OrganizationAccountCategory entity.
// If the OrganizationAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountCategoryMutation) OldAccountTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountTypeID: %w", err)
	}
	return oldValue.AccountTypeID, nil
}

// ResetAccountTypeID resets all changes to the "account_type_id" field.
func (m *OrganizationAccountCategoryMutation) ResetAccountTypeID() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *OrganizationAccountCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationAccountCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationAccountCategory entity.
// If the OrganizationAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationAccountCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationAccountCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationAccountCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrganizationAccountCategory entity.
// If the OrganizationAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationAccountCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organizationaccountcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationAccountCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organizationaccountcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationAccountCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organizationaccountcategory.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationAccountCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationAccountCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationAccountCategory entity.
// If the OrganizationAccountCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationAccountCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAccountIDs adds the "accounts" edge to the OrganizationAccount entity by ids.
func (m *OrganizationAccountCategoryMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the OrganizationAccount entity.
func (m *OrganizationAccountCategoryMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the OrganizationAccount entity was cleared.
func (m *OrganizationAccountCategoryMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the OrganizationAccount entity by IDs.
func (m *OrganizationAccountCategoryMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the OrganizationAccount entity.
func (m *OrganizationAccountCategoryMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *OrganizationAccountCategoryMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *OrganizationAccountCategoryMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// SetTypeID sets the "type" edge to the OrganizationAccountType entity by id.
func (m *OrganizationAccountCategoryMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the OrganizationAccountType entity.
func (m *OrganizationAccountCategoryMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the OrganizationAccountType entity was cleared.
func (m *OrganizationAccountCategoryMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *OrganizationAccountCategoryMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *OrganizationAccountCategoryMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *OrganizationAccountCategoryMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Where appends a list predicates to the OrganizationAccountCategoryMutation builder.
func (m *OrganizationAccountCategoryMutation) Where(ps ...predicate.OrganizationAccountCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationAccountCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationAccountCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationAccountCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationAccountCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationAccountCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationAccountCategory).
func (m *OrganizationAccountCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationAccountCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, organizationaccountcategory.FieldAccountTypeID)
	}
	if m.name != nil {
		fields = append(fields, organizationaccountcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, organizationaccountcategory.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, organizationaccountcategory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationAccountCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationaccountcategory.FieldAccountTypeID:
		return m.AccountTypeID()
	case organizationaccountcategory.FieldName:
		return m.Name()
	case organizationaccountcategory.FieldDescription:
		return m.Description()
	case organizationaccountcategory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationAccountCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationaccountcategory.FieldAccountTypeID:
		return m.OldAccountTypeID(ctx)
	case organizationaccountcategory.FieldName:
		return m.OldName(ctx)
	case organizationaccountcategory.FieldDescription:
		return m.OldDescription(ctx)
	case organizationaccountcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationAccountCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAccountCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationaccountcategory.FieldAccountTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountTypeID(v)
		return nil
	case organizationaccountcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationaccountcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organizationaccountcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationAccountCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationAccountCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAccountCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationAccountCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationAccountCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationaccountcategory.FieldDescription) {
		fields = append(fields, organizationaccountcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationAccountCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationAccountCategoryMutation) ClearField(name string) error {
	switch name {
	case organizationaccountcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationAccountCategoryMutation) ResetField(name string) error {
	switch name {
	case organizationaccountcategory.FieldAccountTypeID:
		m.ResetAccountTypeID()
		return nil
	case organizationaccountcategory.FieldName:
		m.ResetName()
		return nil
	case organizationaccountcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case organizationaccountcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationAccountCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, organizationaccountcategory.EdgeAccounts)
	}
	if m._type != nil {
		edges = append(edges, organizationaccountcategory.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationAccountCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationaccountcategory.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case organizationaccountcategory.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationAccountCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, organizationaccountcategory.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationAccountCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationaccountcategory.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationAccountCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, organizationaccountcategory.EdgeAccounts)
	}
	if m.cleared_type {
		edges = append(edges, organizationaccountcategory.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationAccountCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationaccountcategory.EdgeAccounts:
		return m.clearedaccounts
	case organizationaccountcategory.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationAccountCategoryMutation) ClearEdge(name string) error {
	switch name {
	case organizationaccountcategory.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationAccountCategoryMutation) ResetEdge(name string) error {
	switch name {
	case organizationaccountcategory.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case organizationaccountcategory.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountCategory edge %s", name)
}

// OrganizationAccountTypeMutation represents an operation that mutates the OrganizationAccountType nodes in the graph.
type OrganizationAccountTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	categories          map[int]struct{}
	removedcategories   map[int]struct{}
	clearedcategories   bool
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationAccountType, error)
	predicates          []predicate.OrganizationAccountType
}

var _ ent.Mutation = (*OrganizationAccountTypeMutation)(nil)

// organizationaccounttypeOption allows management of the mutation configuration using functional options.
type organizationaccounttypeOption func(*OrganizationAccountTypeMutation)

// newOrganizationAccountTypeMutation creates new mutation for the OrganizationAccountType entity.
func newOrganizationAccountTypeMutation(c config, op Op, opts ...organizationaccounttypeOption) *OrganizationAccountTypeMutation {
	m := &OrganizationAccountTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationAccountType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationAccountTypeID sets the ID field of the mutation.
func withOrganizationAccountTypeID(id int) organizationaccounttypeOption {
	return func(m *OrganizationAccountTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationAccountType
		)
		m.oldValue = func(ctx context.Context) (*OrganizationAccountType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationAccountType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationAccountType sets the old OrganizationAccountType of the mutation.
func withOrganizationAccountType(node *OrganizationAccountType) organizationaccounttypeOption {
	return func(m *OrganizationAccountTypeMutation) {
		m.oldValue = func(context.Context) (*OrganizationAccountType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationAccountTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationAccountTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationAccountTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationAccountTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationAccountType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationAccountTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationAccountTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationAccountType entity.
// If the OrganizationAccountType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationAccountTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetName sets the "name" field.
func (m *OrganizationAccountTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationAccountTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationAccountType entity.
// If the OrganizationAccountType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationAccountTypeMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationAccountTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationAccountTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationAccountType entity.
// If the OrganizationAccountType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationAccountTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationAccountTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddCategoryIDs adds the "categories" edge to the OrganizationAccountCategory entity by ids.
func (m *OrganizationAccountTypeMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the OrganizationAccountCategory entity.
func (m *OrganizationAccountTypeMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the OrganizationAccountCategory entity was cleared.
func (m *OrganizationAccountTypeMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the OrganizationAccountCategory entity by IDs.
func (m *OrganizationAccountTypeMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the OrganizationAccountCategory entity.
func (m *OrganizationAccountTypeMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *OrganizationAccountTypeMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *OrganizationAccountTypeMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationAccountTypeMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationAccountTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationAccountTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationAccountTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationAccountTypeMutation builder.
func (m *OrganizationAccountTypeMutation) Where(ps ...predicate.OrganizationAccountType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationAccountTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationAccountTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationAccountType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationAccountTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationAccountTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationAccountType).
func (m *OrganizationAccountTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationAccountTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.organization != nil {
		fields = append(fields, organizationaccounttype.FieldOrganizationID)
	}
	if m.name != nil {
		fields = append(fields, organizationaccounttype.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, organizationaccounttype.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationAccountTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationaccounttype.FieldOrganizationID:
		return m.OrganizationID()
	case organizationaccounttype.FieldName:
		return m.Name()
	case organizationaccounttype.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationAccountTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationaccounttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationaccounttype.FieldName:
		return m.OldName(ctx)
	case organizationaccounttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationAccountType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAccountTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationaccounttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationaccounttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationaccounttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationAccountTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationAccountTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAccountTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationAccountType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationAccountTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationAccountTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationAccountTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrganizationAccountType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationAccountTypeMutation) ResetField(name string) error {
	switch name {
	case organizationaccounttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationaccounttype.FieldName:
		m.ResetName()
		return nil
	case organizationaccounttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationAccountTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.categories != nil {
		edges = append(edges, organizationaccounttype.EdgeCategories)
	}
	if m.organization != nil {
		edges = append(edges, organizationaccounttype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationAccountTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationaccounttype.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case organizationaccounttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationAccountTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategories != nil {
		edges = append(edges, organizationaccounttype.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationAccountTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationaccounttype.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationAccountTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategories {
		edges = append(edges, organizationaccounttype.EdgeCategories)
	}
	if m.clearedorganization {
		edges = append(edges, organizationaccounttype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationAccountTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationaccounttype.EdgeCategories:
		return m.clearedcategories
	case organizationaccounttype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationAccountTypeMutation) ClearEdge(name string) error {
	switch name {
	case organizationaccounttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationAccountTypeMutation) ResetEdge(name string) error {
	switch name {
	case organizationaccounttype.EdgeCategories:
		m.ResetCategories()
		return nil
	case organizationaccounttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationAccountType edge %s", name)
}

// OrganizationEventTypeMutation represents an operation that mutates the OrganizationEventType nodes in the graph.
type OrganizationEventTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	description         *string
	rules               *[]schema.EventRules
	appendrules         []schema.EventRules
	created_at          *time.Time
	clearedFields       map[string]struct{}
	events              map[uuid.UUID]struct{}
	removedevents       map[uuid.UUID]struct{}
	clearedevents       bool
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationEventType, error)
	predicates          []predicate.OrganizationEventType
}

var _ ent.Mutation = (*OrganizationEventTypeMutation)(nil)

// organizationeventtypeOption allows management of the mutation configuration using functional options.
type organizationeventtypeOption func(*OrganizationEventTypeMutation)

// newOrganizationEventTypeMutation creates new mutation for the OrganizationEventType entity.
func newOrganizationEventTypeMutation(c config, op Op, opts ...organizationeventtypeOption) *OrganizationEventTypeMutation {
	m := &OrganizationEventTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationEventType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationEventTypeID sets the ID field of the mutation.
func withOrganizationEventTypeID(id int) organizationeventtypeOption {
	return func(m *OrganizationEventTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationEventType
		)
		m.oldValue = func(ctx context.Context) (*OrganizationEventType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationEventType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationEventType sets the old OrganizationEventType of the mutation.
func withOrganizationEventType(node *OrganizationEventType) organizationeventtypeOption {
	return func(m *OrganizationEventTypeMutation) {
		m.oldValue = func(context.Context) (*OrganizationEventType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationEventTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationEventTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationEventTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationEventTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationEventType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationEventTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationEventTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationEventType entity.
// If the OrganizationEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationEventTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationEventTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetName sets the "name" field.
func (m *OrganizationEventTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationEventTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationEventType entity.
// If the OrganizationEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationEventTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationEventTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OrganizationEventTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationEventTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrganizationEventType entity.
// If the OrganizationEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationEventTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationEventTypeMutation) ResetDescription() {
	m.description = nil
}

// SetRules sets the "rules" field.
func (m *OrganizationEventTypeMutation) SetRules(sr []schema.EventRules) {
	m.rules = &sr
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *OrganizationEventTypeMutation) Rules() (r []schema.EventRules, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the OrganizationEventType entity.
// If the OrganizationEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationEventTypeMutation) OldRules(ctx context.Context) (v []schema.EventRules, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds sr to the "rules" field.
func (m *OrganizationEventTypeMutation) AppendRules(sr []schema.EventRules) {
	m.appendrules = append(m.appendrules, sr...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *OrganizationEventTypeMutation) AppendedRules() ([]schema.EventRules, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *OrganizationEventTypeMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationEventTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationEventTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationEventType entity.
// If the OrganizationEventType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationEventTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationEventTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *OrganizationEventTypeMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *OrganizationEventTypeMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *OrganizationEventTypeMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *OrganizationEventTypeMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *OrganizationEventTypeMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *OrganizationEventTypeMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *OrganizationEventTypeMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationEventTypeMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationEventTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationEventTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationEventTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationEventTypeMutation builder.
func (m *OrganizationEventTypeMutation) Where(ps ...predicate.OrganizationEventType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationEventTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationEventTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationEventType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationEventTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationEventTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationEventType).
func (m *OrganizationEventTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationEventTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.organization != nil {
		fields = append(fields, organizationeventtype.FieldOrganizationID)
	}
	if m.name != nil {
		fields = append(fields, organizationeventtype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, organizationeventtype.FieldDescription)
	}
	if m.rules != nil {
		fields = append(fields, organizationeventtype.FieldRules)
	}
	if m.created_at != nil {
		fields = append(fields, organizationeventtype.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationEventTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationeventtype.FieldOrganizationID:
		return m.OrganizationID()
	case organizationeventtype.FieldName:
		return m.Name()
	case organizationeventtype.FieldDescription:
		return m.Description()
	case organizationeventtype.FieldRules:
		return m.Rules()
	case organizationeventtype.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationEventTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationeventtype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationeventtype.FieldName:
		return m.OldName(ctx)
	case organizationeventtype.FieldDescription:
		return m.OldDescription(ctx)
	case organizationeventtype.FieldRules:
		return m.OldRules(ctx)
	case organizationeventtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationEventType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationEventTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationeventtype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationeventtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationeventtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organizationeventtype.FieldRules:
		v, ok := value.([]schema.EventRules)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case organizationeventtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationEventType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationEventTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationEventTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationEventTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationEventType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationEventTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationEventTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationEventTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrganizationEventType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationEventTypeMutation) ResetField(name string) error {
	switch name {
	case organizationeventtype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationeventtype.FieldName:
		m.ResetName()
		return nil
	case organizationeventtype.FieldDescription:
		m.ResetDescription()
		return nil
	case organizationeventtype.FieldRules:
		m.ResetRules()
		return nil
	case organizationeventtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationEventType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationEventTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.events != nil {
		edges = append(edges, organizationeventtype.EdgeEvents)
	}
	if m.organization != nil {
		edges = append(edges, organizationeventtype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationEventTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationeventtype.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case organizationeventtype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationEventTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, organizationeventtype.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationEventTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organizationeventtype.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationEventTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevents {
		edges = append(edges, organizationeventtype.EdgeEvents)
	}
	if m.clearedorganization {
		edges = append(edges, organizationeventtype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationEventTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationeventtype.EdgeEvents:
		return m.clearedevents
	case organizationeventtype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationEventTypeMutation) ClearEdge(name string) error {
	switch name {
	case organizationeventtype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationEventType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationEventTypeMutation) ResetEdge(name string) error {
	switch name {
	case organizationeventtype.EdgeEvents:
		m.ResetEvents()
		return nil
	case organizationeventtype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationEventType edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	transaction_date *time.Time
	transaction_type *enum.TransactionType
	amount           *float64
	addamount        *float64
	notes            *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	account          *int
	clearedaccount   bool
	event            *uuid.UUID
	clearedevent     bool
	done             bool
	oldValue         func(context.Context) (*Transaction, error)
	predicates       []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id uuid.UUID) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventID sets the "event_id" field.
func (m *TransactionMutation) SetEventID(u uuid.UUID) {
	m.event = &u
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *TransactionMutation) EventID() (r uuid.UUID, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldEventID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *TransactionMutation) ResetEventID() {
	m.event = nil
}

// SetTransactionDate sets the "transaction_date" field.
func (m *TransactionMutation) SetTransactionDate(t time.Time) {
	m.transaction_date = &t
}

// TransactionDate returns the value of the "transaction_date" field in the mutation.
func (m *TransactionMutation) TransactionDate() (r time.Time, exists bool) {
	v := m.transaction_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionDate returns the old "transaction_date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionDate: %w", err)
	}
	return oldValue.TransactionDate, nil
}

// ResetTransactionDate resets all changes to the "transaction_date" field.
func (m *TransactionMutation) ResetTransactionDate() {
	m.transaction_date = nil
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionMutation) SetTransactionType(et enum.TransactionType) {
	m.transaction_type = &et
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionMutation) TransactionType() (r enum.TransactionType, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionType(ctx context.Context) (v enum.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetAccountID sets the "account_id" field.
func (m *TransactionMutation) SetAccountID(i int) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TransactionMutation) AccountID() (r int, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TransactionMutation) ResetAccountID() {
	m.account = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransactionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetNotes sets the "notes" field.
func (m *TransactionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *TransactionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *TransactionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[transaction.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *TransactionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[transaction.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *TransactionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, transaction.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAccount clears the "account" edge to the OrganizationAccount entity.
func (m *TransactionMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the OrganizationAccount entity was cleared.
func (m *TransactionMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *TransactionMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *TransactionMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *TransactionMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *TransactionMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.event != nil {
		fields = append(fields, transaction.FieldEventID)
	}
	if m.transaction_date != nil {
		fields = append(fields, transaction.FieldTransactionDate)
	}
	if m.transaction_type != nil {
		fields = append(fields, transaction.FieldTransactionType)
	}
	if m.account != nil {
		fields = append(fields, transaction.FieldAccountID)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.notes != nil {
		fields = append(fields, transaction.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldEventID:
		return m.EventID()
	case transaction.FieldTransactionDate:
		return m.TransactionDate()
	case transaction.FieldTransactionType:
		return m.TransactionType()
	case transaction.FieldAccountID:
		return m.AccountID()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldNotes:
		return m.Notes()
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldEventID:
		return m.OldEventID(ctx)
	case transaction.FieldTransactionDate:
		return m.OldTransactionDate(ctx)
	case transaction.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transaction.FieldAccountID:
		return m.OldAccountID(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldNotes:
		return m.OldNotes(ctx)
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldEventID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case transaction.FieldTransactionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionDate(v)
		return nil
	case transaction.FieldTransactionType:
		v, ok := value.(enum.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transaction.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldNotes) {
		fields = append(fields, transaction.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldEventID:
		m.ResetEventID()
		return nil
	case transaction.FieldTransactionDate:
		m.ResetTransactionDate()
		return nil
	case transaction.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transaction.FieldAccountID:
		m.ResetAccountID()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldNotes:
		m.ResetNotes()
		return nil
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, transaction.EdgeAccount)
	}
	if m.event != nil {
		edges = append(edges, transaction.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, transaction.EdgeAccount)
	}
	if m.clearedevent {
		edges = append(edges, transaction.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeAccount:
		return m.clearedaccount
	case transaction.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeAccount:
		m.ClearAccount()
		return nil
	case transaction.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeAccount:
		m.ResetAccount()
		return nil
	case transaction.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	email                *string
	name                 *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	organizations        map[uuid.UUID]struct{}
	removedorganizations map[uuid.UUID]struct{}
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOrganizationIDs(ids ...uuid.UUID) {
	if m.organizations == nil {
		m.organizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *UserMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOrganizationIDs(ids ...uuid.UUID) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *UserMutation) OrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *UserMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldName:
		return m.Name()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganizations {
		edges = append(edges, user.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
